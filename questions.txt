Ruby on Rails

1. Quelles seraient les premières étapes à prendre pour refacto un projet où les controllers sont trop longs?

> 1) S'assurer une bonne couverture de tests pour chaque action du controller (functional tests) avant d'entamer un refactoring du controller.
     On veut ainsi tester comment l'action du controller gère la requête et le résultat attendue. Des tests verts a la fin du refactoring nous confirme que le refactoring n'a pas changé la logique attendue.

  2) Bouger la logique métier du controller au model (Idéalement les actions du controller ne devraient faire que quelques lignes) (Fat Models / Skinny Controllers)

  3) Éviter des models trop gros avec beaucoup de logique métier :
       - Se référer aux SOLID principles notamment Single Responsibility : Un model dédié a une seule tache précise.
       - Créer des services chacun avec une spécificité, que l'on appellera en fonction des besoins dans ses models (Fat Services / Skinny Models / Skinny Controllers)
       - Utiliser les concerns en rails pour alléger les models


2. Qu'est-ce que le N+1 et comment l'éviter en Rails?

> Le N+1 problème. C'est une manière très inefficace de query la base de donnée, problème qui apparait souvent lors de l'usage d'un ORM. En termes de Big-O notation, on va être avec un algorithme avec une runtime complexity de O(N), c'est-à-dire un temps d'exécution de l'algorithme qui va grossir de manière linéaire en fonction du size de N. On va donc se retrouver a spammer sa database de N queries + 1.
  Ce problème apparait lorsque l'on a une association/relation de type parent-enfant entre 2 models. On va en general récupérer une liste de parent ids et récupérer les enfants un à un.
  Par exemple :
  ```SELECT id FROM Parent;```
  ```SELECT * FROM Enfant WHERE parent_id = 1;```
  ```SELECT * FROM Enfant WHERE parent_id = 2;```
  ```SELECT * FROM Enfant WHERE parent_id = 3;```
  ```SELECT * FROM Enfant WHERE parent_id = 4;```
  ```...```
  ```...```
  ```SELECT * FROM Enfant WHERE parent_id = N;```
  Rails utilise la méthode 'includes' avec Active Record qui va nous permettre d'avoir un algorithme avec une runtime complexity de O(2) et un temps d'exécution qui va être constant, peu importe la taille du dataset
  ```SELECT id FROM Parent;```
  ```SELECT * FROM Enfant WHERE parent_id IN (1, 2, 3, 4, ...);```

3. D'un point de vue pratique, quel intérêt à utiliser des constantes dans une app Rails? Quelles implémentations avez-vous vu/mis en place?

> En ruby, on utilise les constantes pour représenter une valeur qui ne changera pas durant toute l'exécution du programme (on utilise par ailleurs souvent freeze pour s'assurer de l'immutabilité de ces constantes).
En rails, il peut être intéressant de définir des constantes dans les fichiers de configuration, constantes qui seront accessible dans l'ensemble du projet au moment de l'exécution du programme.
Par exemple dans config/environments/*.rb ou alors comme variable d'environnement via des gems comme dotenv/figaro

4. Décrivez une fonction de Ruby trop peu utilisée à votre goût

> J'aime beaucoup flat_map du module Enumerable qui je trouve est peu utilisé ; on va exécuter un block de code sur chaque élément et retourner un array 'flatten' d'un niveau : [1, [2], [[3, 4]]] => [1, 2, [3, 4]]
De plus, on trouve plus souvent le pattern map.flatten alors que flat_map est selon moi plus élégant et plus rapide.
J'aime beaucoup également en ruby le 'Safe Navigation Operator' `&.` qui est encore trop peu utilisé selon moi.

Architecture

1. Une entreprise veut créer un système de notification pour son site.
Chaque type de notification a besoin de 'variables' différentes:
(x a aimé le projet de y, le projet x vient d'être mis à jour, etc.)
La base de données est en PostgreSQL.
Proposez une structure de données et une implémentation en back-end qui permettrait d'être assez flexible
tout en réduisant la possibilité de bugs et de structures non conformes

> Models :

- User

{
  id: int (pk)
  name: varchar
  email: varchar
  created_at: datetime
  updated_at: datetime
  last_login: datatime
}

- Entity (Notification : vient d'un user, d'un groupe specific, d'une page facebook specific, etc...)

{
  id: int (pk)
  name: varchar
  entity_category_id: smallint (fk)
  user_id: int (fk) can be nil
  created_at: datetime
  updated_at: datetime
}

- Entity Category (User / Group / Page)

{
  id: int (pk)
  category: 'User'
}

- Post

{
  id: int (pk)
  content: varchar
  entity_id: int (fk)
  created_at: datetime
  updated_at: datetime
}

- UserFollow

{
  #pk = user_id + entity_id
  user_id: int (fk)
  entity_id: int (fk)
  created_at: datetime
  updated_at: datetime
}

- PostSentToUser

{
  id: int (pk)
  post_id: int (fk)
  user_id: int (fk)
  entity_id: int (fk)
  sent_at: datetime can be nil
  created_at: datetime
  updated_at: datetime
}


Flow ->
1) Entity ou User créer un nouveau Post (par exemple POST requête via une REST API).
2) La requête passe par un web server puis un app server et le post est sauvegarde dans une database
3) Service / Script (par exemple system de callback une fois que le message est sauvegarde) qui génère/push plusieurs messages pour chaque follower du post à travers un message broker(par exemple RabbitMQ). Possibilite de run un backgroundjob regulierement pour send les posts qui n'auraient pas ete envoye.
4) Creation d'un service 'Notification Service' avec l'utilisation de Server-Sent Events(SEE) technologie comme "Push model / Fan-out-on-write" protocole. Moins complique à implémenter que le web socket protocole et notre architecture ne nécessité pas un 'bi-directional communication channel'. On à seulement besoin d'une communication server -> client
4) Client(User browser) <-- 'Notification Service' <--> Message Broker
- Quand le client se connecte, 'Notificiation Service' consume les messages pour le client et envoi les informations au client

2. Décrivez les objets et la structure de donnée que vous utiliseriez pour implémenter un jeu de Touché-Coulé

>

Rules # Regles du jeu / Définis les règles du jeu (Par exemple, le nombre de bateaux et combien pour chaque type)
{
  battleship: 1
  cruiser: 2
  destroyer: 3
}


GameMaster # Initialise le game state / rules / Gère les actions du current joueur (place_boat / shoot boat) / Check score

{
  rules: rules
  game_state: game_state
}

GameState # Représentation en mémoire de l'état globale du jeu

{
  players: players
  turn_tracker: turn_tracker
  score: score # Logic qui décide de la victoire d'un joueur quand celui-ci perds tous ces bateaux
}

TurnTracker # Permet de savoir quel joueur va jouer

{
  players: players
  actual_turn: integer # 1 / 2
}

Player # Pouvoir consulter L'état de sa propre grille / celle de l'adversaire / le positionnement de ces bateaux

{
  id: integer
  grid: grid #freeze (only game master can update this grid)
  opponent_grid: grid #freeze (only game master can update this grid)
  ships: ships
}

Grid

{
  boxes: boxes
}

Box

{
  id: string # "A1", "A2", etc..
  combat_status: string # "hit" / "miss"
  location_status: string # "empty water" / "ship structure"
}

# Alternatively for boxes

OpponentBox

{
  id: string # "A1", "A2", etc..
  combat_status: string # "hit" / "miss"
}

PersonalBox

{
  id: string # "A1", "A2", etc..
  location_status: string # "empty water" / "ship structure"
}

Ship

{
  type: string # "Battleship"
  size: integer # 4
  hit_count: integer
  sunk: boolean
  position_on_grind: hash
}
